import socket
#TODO: eigene Klasse
p = 200

def generateChallenge(amountOfItems):
    challengeSet = {}
    while len(challengeSet<200):
        challengeSet.add(random.randint(0,n-1))
    return challengeSet

#Create socket object
udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

#Destination address and port
address = ('localhost', 12345)
port = 1024
udp_socket.bind(address)

#Device settings
DeviceId = 1337
SessionId = 42
SecureVault = [] # TODO: placeholder for secure vault
for i in range(1000): 
    SecureVault.append(i)

#Send first message
M1 = str(DeviceId) + str(SessionId)

try:
    udp_socket.sendto(M1.encode(), address)  
except socket.error as e:
    print(f"Send M1 failed: {e}")
        
# Receive data from server
data, addr = udp_socket.recvfrom(port)
print(f"Received data: {data.decode()}")

C1_received = generateChallenge(p)  #TODO: aus received data rausnehmen

#Check if correct randomness
if(false):    #TODO: r1 rausziehen r1_received!=r1
    print("Error, not the correct randomness")
    udp_socket.close() 


# Generate key k1 from the keys in the challenge    
k1 = 0 
for i in C1_received:
    k1 = k1^SecureVault[i] # TODO Test if this is correct
# TODO k1 should be of size m bits now --- test that

t1 = random.randint(0, randmax) #random number generated by the IoT device
C2 = generateChallenge(p)
while(C2.items.sort() == C1_received.items.sort()):
    C2 = generateChallenge(p)
r2 = random.randint(0,randmax)
# M3 = Enc(k1, r1||t1||{C2,r2})
# TODO send M3
    
# Close the socket
print()
udp_socket.close()